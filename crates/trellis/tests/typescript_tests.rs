//! Integration tests for the TypeScript type generation macro.

use trellis::typescript;

#[derive(Clone)]
struct UserService;

#[typescript(namespace = "Api")]
impl UserService {
    /// Get user by ID
    pub fn get_user(&self, id: String) -> String {
        id
    }

    /// List all users
    pub fn list_users(&self) -> Vec<String> {
        vec![]
    }

    /// Create a new user
    pub fn create_user(&self, name: String, email: String) -> String {
        name
    }

    /// Delete a user
    pub fn delete_user(&self, id: String) -> bool {
        true
    }

    /// Update user email
    pub fn update_user(&self, id: String, email: Option<String>) -> String {
        id
    }
}

#[test]
fn test_typescript_generated() {
    let ts = UserService::typescript_types();

    // Should have generated header
    assert!(
        ts.contains("// Generated by trellis"),
        "Should have generated header"
    );
}

#[test]
fn test_typescript_namespace() {
    let ts = UserService::typescript_types();

    // Should wrap in namespace
    assert!(
        ts.contains("export namespace Api"),
        "Should have namespace wrapper"
    );
}

#[test]
fn test_typescript_request_interfaces() {
    let ts = UserService::typescript_types();

    // Check request interfaces
    assert!(
        ts.contains("export interface GetUserRequest"),
        "Should have GetUserRequest"
    );
    assert!(
        ts.contains("export interface CreateUserRequest"),
        "Should have CreateUserRequest"
    );
    assert!(
        ts.contains("export interface ListUsersRequest"),
        "Should have ListUsersRequest"
    );
}

#[test]
fn test_typescript_response_interfaces() {
    let ts = UserService::typescript_types();

    // Check response interfaces
    assert!(
        ts.contains("export interface GetUserResponse"),
        "Should have GetUserResponse"
    );
    assert!(
        ts.contains("export interface CreateUserResponse"),
        "Should have CreateUserResponse"
    );
}

#[test]
fn test_typescript_service_interface() {
    let ts = UserService::typescript_types();

    // Check service interface
    assert!(
        ts.contains("export interface UserServiceService"),
        "Should have service interface"
    );

    // Check method definitions (camelCase)
    assert!(
        ts.contains("getUser(request: GetUserRequest): Promise<GetUserResponse>"),
        "Should have getUser method"
    );
    assert!(
        ts.contains("createUser(request: CreateUserRequest): Promise<CreateUserResponse>"),
        "Should have createUser method"
    );
}

#[test]
fn test_typescript_field_types() {
    let ts = UserService::typescript_types();

    // String fields should be string type
    assert!(ts.contains(": string;"), "Should have string type");

    // Boolean return should be boolean
    assert!(ts.contains("result: boolean"), "Should have boolean result");
}

#[test]
fn test_typescript_optional_fields() {
    let ts = UserService::typescript_types();

    // Optional fields should have ?
    assert!(ts.contains("email?:"), "Should have optional email field");
}

#[test]
fn test_typescript_doc_comments() {
    let ts = UserService::typescript_types();

    // Doc comments should be JSDoc
    assert!(
        ts.contains("/** Get user by ID */"),
        "Should have JSDoc comments"
    );
}

// Test without namespace
#[derive(Clone)]
struct SimpleService;

#[typescript]
impl SimpleService {
    pub fn do_thing(&self) -> String {
        "done".to_string()
    }
}

#[test]
fn test_typescript_no_namespace() {
    let ts = SimpleService::typescript_types();

    // Should not have namespace wrapper
    assert!(
        !ts.contains("export namespace"),
        "Should not have namespace wrapper"
    );

    // Should still have interfaces at top level
    assert!(
        ts.contains("export interface DoThingRequest"),
        "Should have request interface"
    );
}

// Test various return types
#[derive(Clone)]
struct TypeService;

#[typescript]
impl TypeService {
    pub fn get_int(&self) -> i32 {
        42
    }

    pub fn get_float(&self) -> f64 {
        3.14
    }

    pub fn get_bool(&self) -> bool {
        true
    }

    pub fn get_array(&self) -> Vec<String> {
        vec![]
    }

    pub fn do_nothing(&self) {}
}

#[test]
fn test_typescript_number_types() {
    let ts = TypeService::typescript_types();

    // Numeric types should all be number
    assert!(
        ts.contains("result: number"),
        "Should map numeric types to number"
    );
}

#[test]
fn test_typescript_array_type() {
    let ts = TypeService::typescript_types();

    // Vec should be array
    assert!(
        ts.contains("unknown[]"),
        "Should map Vec to array, got:\n{}",
        ts
    );
}

#[test]
fn test_typescript_void_return() {
    let ts = TypeService::typescript_types();

    // Unit return type should produce empty interface
    assert!(
        ts.contains("export interface DoNothingResponse {}"),
        "Should have empty response for unit return"
    );
}
