//! Integration tests for the Python type stub generation macro.

use trellis::python;

#[derive(Clone)]
struct UserService;

#[python(module = "user_api")]
impl UserService {
    /// Get user by ID
    pub fn get_user(&self, id: String) -> String {
        id
    }

    /// List all users
    pub fn list_users(&self) -> Vec<String> {
        vec![]
    }

    /// Create a new user
    pub fn create_user(&self, name: String, email: String) -> String {
        name
    }

    /// Delete a user
    pub fn delete_user(&self, id: String) -> bool {
        true
    }

    /// Update user email
    pub fn update_user(&self, id: String, email: Option<String>) -> String {
        id
    }
}

#[test]
fn test_python_stubs_generated() {
    let stubs = UserService::python_stubs();

    // Should have generated header
    assert!(
        stubs.contains("# Generated by trellis"),
        "Should have generated header"
    );
}

#[test]
fn test_python_module_comment() {
    let stubs = UserService::python_stubs();

    // Should have module comment
    assert!(
        stubs.contains("user_api"),
        "Should have module name in comment"
    );
}

#[test]
fn test_python_imports() {
    let stubs = UserService::python_stubs();

    // Should have typing imports
    assert!(
        stubs.contains("from typing import TypedDict"),
        "Should have TypedDict import"
    );
    assert!(
        stubs.contains("Optional"),
        "Should have Optional import"
    );
    assert!(stubs.contains("List"), "Should have List import");
}

#[test]
fn test_python_request_typeddict() {
    let stubs = UserService::python_stubs();

    // Check request TypedDicts
    assert!(
        stubs.contains("class Get_userRequest(TypedDict)"),
        "Should have GetUserRequest TypedDict"
    );
    assert!(
        stubs.contains("class Create_userRequest(TypedDict)"),
        "Should have CreateUserRequest TypedDict"
    );
}

#[test]
fn test_python_response_typeddict() {
    let stubs = UserService::python_stubs();

    // Check response TypedDicts
    assert!(
        stubs.contains("class Get_userResponse(TypedDict)"),
        "Should have GetUserResponse TypedDict"
    );
    assert!(
        stubs.contains("class Create_userResponse(TypedDict)"),
        "Should have CreateUserResponse TypedDict"
    );
}

#[test]
fn test_python_class() {
    let stubs = UserService::python_stubs();

    // Check class definition
    assert!(
        stubs.contains("class UserService:"),
        "Should have class definition"
    );
}

#[test]
fn test_python_method_stubs() {
    let stubs = UserService::python_stubs();

    // Check method definitions (snake_case)
    assert!(
        stubs.contains("def get_user(self, request: Get_userRequest)"),
        "Should have get_user method"
    );
    assert!(
        stubs.contains("def create_user(self, request: Create_userRequest)"),
        "Should have create_user method"
    );
}

#[test]
fn test_python_field_types() {
    let stubs = UserService::python_stubs();

    // String fields should be str
    assert!(stubs.contains(": str"), "Should have str type");

    // Boolean should be bool
    assert!(
        stubs.contains("result: bool"),
        "Should have bool result type"
    );
}

#[test]
fn test_python_optional_fields() {
    let stubs = UserService::python_stubs();

    // Optional fields should use Optional
    assert!(
        stubs.contains("Optional["),
        "Should have Optional type for optional fields"
    );
}

#[test]
fn test_python_docstrings() {
    let stubs = UserService::python_stubs();

    // Doc comments should be docstrings
    assert!(
        stubs.contains("\"\"\"Get user by ID\"\"\""),
        "Should have docstring"
    );
}

// Test default module name
#[derive(Clone)]
struct SimpleService;

#[python]
impl SimpleService {
    pub fn do_thing(&self) -> String {
        "done".to_string()
    }
}

#[test]
fn test_python_default_module() {
    let stubs = SimpleService::python_stubs();

    // Default module should be snake_case struct name
    assert!(
        stubs.contains("simple_service"),
        "Should have default module name"
    );
}

// Test various return types
#[derive(Clone)]
struct TypeService;

#[python]
impl TypeService {
    pub fn get_int(&self) -> i32 {
        42
    }

    pub fn get_float(&self) -> f64 {
        3.14
    }

    pub fn get_bool(&self) -> bool {
        true
    }

    pub fn get_array(&self) -> Vec<String> {
        vec![]
    }

    pub fn do_nothing(&self) {}
}

#[test]
fn test_python_int_type() {
    let stubs = TypeService::python_stubs();

    // Should have int result
    assert!(
        stubs.contains("result: int"),
        "Should map integer types to int"
    );
}

#[test]
fn test_python_float_type() {
    let stubs = TypeService::python_stubs();

    // Should have float result
    assert!(
        stubs.contains("result: float"),
        "Should map float types to float"
    );
}

#[test]
fn test_python_list_type() {
    let stubs = TypeService::python_stubs();

    // Should have List type
    assert!(
        stubs.contains("result: List[Any]"),
        "Should map Vec to List"
    );
}

#[test]
fn test_python_empty_response() {
    let stubs = TypeService::python_stubs();

    // Unit return should use pass
    assert!(
        stubs.contains("class Do_nothingResponse(TypedDict):\n    \"\"\"Response for do_nothing method.\"\"\"\n    pass"),
        "Unit return should have pass"
    );
}
