//! Python type stub generation macro.
//!
//! Generates Python .pyi type stubs from Rust impl blocks.
//! Useful for providing type hints to Python code interacting with Rust APIs.

use heck::ToSnakeCase;

use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{parse::Parse, ItemImpl, Token};
use trellis_parse::{extract_methods, get_impl_name, MethodInfo, ParamInfo};

/// Arguments for the #[python] attribute
#[derive(Default)]
pub(crate) struct PythonArgs {
    /// Module name
    module: Option<String>,
}

impl Parse for PythonArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut args = PythonArgs::default();

        while !input.is_empty() {
            let ident: syn::Ident = input.parse()?;
            input.parse::<Token![=]>()?;

            match ident.to_string().as_str() {
                "module" => {
                    let lit: syn::LitStr = input.parse()?;
                    args.module = Some(lit.value());
                }
                other => {
                    return Err(syn::Error::new(
                        ident.span(),
                        format!("unknown argument `{other}`. Valid arguments: module"),
                    ));
                }
            }

            if input.peek(Token![,]) {
                input.parse::<Token![,]>()?;
            }
        }

        Ok(args)
    }
}


pub(crate) fn expand_python(args: PythonArgs, impl_block: ItemImpl) -> syn::Result<TokenStream2> {
    let struct_name = get_impl_name(&impl_block)?;
    let struct_name_str = struct_name.to_string();
    let methods = extract_methods(&impl_block)?;

    let module_name = args
        .module
        .unwrap_or_else(|| struct_name_str.to_snake_case());

    // Generate TypedDict classes for request/response types
    let typed_dicts: Vec<String> = methods
        .iter()
        .flat_map(generate_typed_dicts)
        .collect();

    // Generate method stubs
    let method_stubs: Vec<String> = methods
        .iter()
        .map(generate_method_stub)
        .collect();

    // Generate the class stub
    let class_stub = format!(
        r#"class {}:
    """Generated service class."""

{}"#,
        struct_name_str,
        method_stubs
            .iter()
            .map(|s| indent_lines(s, 4))
            .collect::<Vec<_>>()
            .join("\n\n")
    );

    // Combine all Python code
    let pyi_code = format!(
        r#"# Generated by trellis
# Python type stubs for {module}

from typing import TypedDict, Optional, List, Dict, Any

{typed_dicts}

{class_stub}
"#,
        module = module_name,
        typed_dicts = typed_dicts.join("\n\n"),
        class_stub = class_stub
    );

    Ok(quote! {
        #impl_block

        impl #struct_name {
            /// Get Python type stubs for this service.
            pub fn python_stubs() -> &'static str {
                #pyi_code
            }

            /// Write Python stubs to a file.
            pub fn write_python_stubs(path: impl AsRef<std::path::Path>) -> std::io::Result<()> {
                std::fs::write(path, Self::python_stubs())
            }
        }
    })
}

/// Generate TypedDict classes for request/response
fn generate_typed_dicts(method: &MethodInfo) -> Vec<String> {
    let method_name = method.name.to_string();
    let request_name = format!("{}Request", capitalize(&method_name));
    let response_name = format!("{}Response", capitalize(&method_name));

    // Generate request TypedDict
    let request_fields: Vec<String> = method
        .params
        .iter()
        .map(generate_field)
        .collect();

    let request_dict = if request_fields.is_empty() {
        format!(
            r#"class {}(TypedDict):
    """Request for {} method."""
    pass"#,
            request_name, method_name
        )
    } else {
        format!(
            r#"class {}(TypedDict):
    """Request for {} method."""
{}"#,
            request_name,
            method_name,
            request_fields.join("\n")
        )
    };

    // Generate response TypedDict
    let ret = &method.return_info;
    let response_dict = if ret.is_unit {
        format!(
            r#"class {}(TypedDict):
    """Response for {} method."""
    pass"#,
            response_name, method_name
        )
    } else {
        let py_type = rust_type_to_python(&ret.ty);
        format!(
            r#"class {}(TypedDict):
    """Response for {} method."""
    result: {}"#,
            response_name, method_name, py_type
        )
    };

    vec![request_dict, response_dict]
}

/// Generate a Python field definition
fn generate_field(param: &ParamInfo) -> String {
    let name = param.name.to_string().to_snake_case();
    let py_type = rust_type_to_python(&Some(param.ty.clone()));
    if param.is_optional {
        format!("    {}: Optional[{}]", name, py_type)
    } else {
        format!("    {}: {}", name, py_type)
    }
}

/// Generate method stub
fn generate_method_stub(method: &MethodInfo) -> String {
    let method_name = method.name.to_string().to_snake_case();
    let request_name = format!("{}Request", capitalize(&method.name.to_string()));
    let response_name = format!("{}Response", capitalize(&method.name.to_string()));

    let doc = method
        .docs
        .as_ref()
        .map(|d| format!("\n    \"\"\"{}\"\"\"", d))
        .unwrap_or_default();

    let async_prefix = if method.is_async { "async " } else { "" };

    format!(
        r#"{}def {}(self, request: {}) -> {}:{}"#,
        async_prefix, method_name, request_name, response_name, doc
    )
}

/// Convert Rust type to Python type
fn rust_type_to_python(ty: &Option<syn::Type>) -> &'static str {
    let Some(ty) = ty else {
        return "None";
    };

    let type_str = quote!(#ty).to_string();

    // Check container types first (note: quote! adds spaces)
    if type_str.contains("Vec<") || type_str.contains("Vec <") {
        "List[Any]"
    } else if type_str.contains("Option<") || type_str.contains("Option <") {
        "Optional[Any]"
    } else if type_str.contains("HashMap") || type_str.contains("BTreeMap") {
        "Dict[str, Any]"
    } else if type_str.contains("String") || type_str.contains("str") {
        "str"
    } else if type_str.contains("i8")
        || type_str.contains("i16")
        || type_str.contains("i32")
        || type_str.contains("i64")
        || type_str.contains("u8")
        || type_str.contains("u16")
        || type_str.contains("u32")
        || type_str.contains("u64")
    {
        "int"
    } else if type_str.contains("f32") || type_str.contains("f64") {
        "float"
    } else if type_str.contains("bool") {
        "bool"
    } else {
        "Any"
    }
}

/// Capitalize first letter
fn capitalize(s: &str) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().chain(c).collect(),
    }
}

/// Indent all lines by the given number of spaces
fn indent_lines(s: &str, spaces: usize) -> String {
    let indent = " ".repeat(spaces);
    s.lines()
        .map(|line| format!("{}{}", indent, line))
        .collect::<Vec<_>>()
        .join("\n")
}
