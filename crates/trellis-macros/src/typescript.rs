//! TypeScript type generation macro.
//!
//! Generates TypeScript interfaces and type definitions from Rust impl blocks.
//! Useful for frontend developers consuming Rust APIs.

use heck::{ToLowerCamelCase, ToPascalCase};

use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{parse::Parse, ItemImpl, Token};
use trellis_parse::{extract_methods, get_impl_name, MethodInfo, ParamInfo};

/// Arguments for the #[typescript] attribute
#[derive(Default)]
pub(crate) struct TypeScriptArgs {
    /// Namespace/module name for the types
    namespace: Option<String>,
}

impl Parse for TypeScriptArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut args = TypeScriptArgs::default();

        while !input.is_empty() {
            let ident: syn::Ident = input.parse()?;
            input.parse::<Token![=]>()?;

            match ident.to_string().as_str() {
                "namespace" => {
                    let lit: syn::LitStr = input.parse()?;
                    args.namespace = Some(lit.value());
                }
                other => {
                    return Err(syn::Error::new(
                        ident.span(),
                        format!("unknown argument `{other}`. Valid arguments: namespace"),
                    ));
                }
            }

            if input.peek(Token![,]) {
                input.parse::<Token![,]>()?;
            }
        }

        Ok(args)
    }
}


pub(crate) fn expand_typescript(args: TypeScriptArgs, impl_block: ItemImpl) -> syn::Result<TokenStream2> {
    let struct_name = get_impl_name(&impl_block)?;
    let struct_name_str = struct_name.to_string();
    let methods = extract_methods(&impl_block)?;

    let namespace = args.namespace;

    // Generate interfaces for request/response types
    let interfaces: Vec<String> = methods
        .iter()
        .flat_map(generate_interfaces)
        .collect();

    // Generate method type definitions
    let method_types: Vec<String> = methods.iter().map(generate_method_type).collect();

    // Generate the service interface
    let service_methods: Vec<String> = methods
        .iter()
        .map(|m| {
            let method_name = m.name.to_string().to_lower_camel_case();
            let request_name = format!("{}Request", m.name.to_string().to_pascal_case());
            let response_name = format!("{}Response", m.name.to_string().to_pascal_case());
            let doc = m
                .docs
                .as_ref()
                .map(|d| format!("  /** {} */\n", d))
                .unwrap_or_default();
            format!(
                "{}  {}(request: {}): Promise<{}>;",
                doc, method_name, request_name, response_name
            )
        })
        .collect();

    let service_interface = format!(
        "export interface {}Service {{\n{}\n}}",
        struct_name_str,
        service_methods.join("\n")
    );

    // Combine all TypeScript code
    let ts_code = if let Some(ns) = namespace {
        format!(
            "// Generated by trellis\n\nexport namespace {} {{\n{}\n\n{}\n\n{}\n}}\n",
            ns,
            indent_lines(&interfaces.join("\n\n"), 2),
            indent_lines(&method_types.join("\n\n"), 2),
            indent_lines(&service_interface, 2)
        )
    } else {
        format!(
            "// Generated by trellis\n\n{}\n\n{}\n\n{}\n",
            interfaces.join("\n\n"),
            method_types.join("\n\n"),
            service_interface
        )
    };

    Ok(quote! {
        #impl_block

        impl #struct_name {
            /// Get TypeScript type definitions for this service.
            pub fn typescript_types() -> &'static str {
                #ts_code
            }

            /// Write TypeScript types to a file.
            pub fn write_typescript(path: impl AsRef<std::path::Path>) -> std::io::Result<()> {
                std::fs::write(path, Self::typescript_types())
            }
        }
    })
}

/// Generate TypeScript interfaces for request/response
fn generate_interfaces(method: &MethodInfo) -> Vec<String> {
    let op_name = method.name.to_string().to_pascal_case();
    let request_name = format!("{}Request", op_name);
    let response_name = format!("{}Response", op_name);

    // Generate request interface
    let request_fields: Vec<String> = method
        .params
        .iter()
        .map(generate_field)
        .collect();

    let request_interface = if request_fields.is_empty() {
        format!("export interface {} {{}}", request_name)
    } else {
        format!(
            "export interface {} {{\n{}\n}}",
            request_name,
            request_fields.join("\n")
        )
    };

    // Generate response interface
    let ret = &method.return_info;
    let response_interface = if ret.is_unit {
        format!("export interface {} {{}}", response_name)
    } else {
        let ts_type = rust_type_to_typescript(&ret.ty);
        format!(
            "export interface {} {{\n  result: {};\n}}",
            response_name, ts_type
        )
    };

    vec![request_interface, response_interface]
}

/// Generate TypeScript field definition
fn generate_field(param: &ParamInfo) -> String {
    let name = param.name.to_string().to_lower_camel_case();
    let ts_type = rust_type_to_typescript(&Some(param.ty.clone()));
    let optional = if param.is_optional { "?" } else { "" };
    format!("  {}{}: {};", name, optional, ts_type)
}

/// Generate method type alias
fn generate_method_type(method: &MethodInfo) -> String {
    let op_name = method.name.to_string().to_pascal_case();
    let request_name = format!("{}Request", op_name);
    let response_name = format!("{}Response", op_name);

    format!(
        "export type {}Fn = (request: {}) => Promise<{}>;",
        op_name, request_name, response_name
    )
}

/// Convert Rust type to TypeScript type
fn rust_type_to_typescript(ty: &Option<syn::Type>) -> &'static str {
    let Some(ty) = ty else {
        return "void";
    };

    let type_str = quote!(#ty).to_string();

    // Check container types first (before checking inner types)
    // Note: quote! adds spaces, so check for "Vec <" as well
    if type_str.contains("Vec<") || type_str.contains("Vec <") {
        // Simple array type - could be enhanced to parse inner type
        "unknown[]"
    } else if type_str.contains("Option<") || type_str.contains("Option <") {
        // Could be enhanced to parse inner type
        "unknown | null"
    } else if type_str.contains("HashMap") || type_str.contains("BTreeMap") || type_str.contains("HashMap <") || type_str.contains("BTreeMap <") {
        "Record<string, unknown>"
    } else if type_str.contains("String") || type_str.contains("str") {
        "string"
    } else if type_str.contains("i8")
        || type_str.contains("i16")
        || type_str.contains("i32")
        || type_str.contains("i64")
        || type_str.contains("u8")
        || type_str.contains("u16")
        || type_str.contains("u32")
        || type_str.contains("u64")
        || type_str.contains("f32")
        || type_str.contains("f64")
    {
        "number"
    } else if type_str.contains("bool") {
        "boolean"
    } else {
        "unknown"
    }
}

/// Indent all lines by the given number of spaces
fn indent_lines(s: &str, spaces: usize) -> String {
    let indent = " ".repeat(spaces);
    s.lines()
        .map(|line| {
            if line.is_empty() {
                String::new()
            } else {
                format!("{}{}", indent, line)
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}
